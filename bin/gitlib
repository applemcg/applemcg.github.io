gitlib_copyright () 
{ 
    cat <<EOF

Copyright (c)2 2015-2020 Marty McGowan, JYATL - Just Yet Another Testing Lab

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

EOF

}
gitlib_version () 
{ 
    printf "%s\t%s\n" gitlib 0.5.0
}
git_pullclone () 
{ 
    [[ -e $1 ]] && { 
        comment Fetching master latest pull for: $2;
        ignore pushd $1;
        cgit pull;
        ignore popd
    } || { 
        comment Cloning $2;
        cgit clone $2
    }
}
git_init () 
{ 
    : when this becomes and APP, may be overridden;
    : by defining a git_user, which in the App World,;
    : is invoked _after_ any _init function;
    git_account applemcg;
    comment main
}
git_account () 
{ 
    : set or return the account name of;
    case $# in 
        0)
            echo ${GIT_ACCOUNT}
        ;;
        *)
            setenv GIT_ACCOUNT $1
        ;;
    esac
}
findClean () 
{ 
    grep "$1" - | sed "s/.*$1 *//"
}
subcmmd () 
{ 
    grep '^ *[a-z[a-z]*)$' | sed 's/)$//; s/ */git /' $*
}
mygithub () 
{ 
    case $1 in 
        *@)
            separator=":"
        ;;
        *//)
            separator="/"
        ;;
    esac;
    echo ${1}github.com${separator}$(git_account)/$(basename $PWD).git
}
git_modified () 
{ 
    : list the modified GIT files;
    : date: 2020-07-27;
    git status | awk '$1 ~ /modified:/ { print $2 }'
}
git_deleted () 
{ 
    cgit status | grep deleted: | field 2
}
git_mods () 
{ 
    cgit status | findClean modified:;
    git status | findClean "new file:"
}
git_hub () 
{ 
    mygithub https://
}
git_ssh () 
{ 
    mygithub git@
}
git_push () 
{ 
    : to remember the origin;
    : date: 2020-03-28;
    comment cgit push $(remote_repo) ${1:-master};
    cgit push $(remote_repo) ${1:-master}
}
git_add () 
{ 
    cgit add "$@"
}
git_name () 
{ 
    ignore pushd .;
    while [[ $PWD != "/" ]]; do
        [[ -d .git ]] && { 
            basename $PWD;
            break
        };
        cd ..;
    done;
    ignore popd
}
git_clone () 
{ 
    indir .. cgit clone $(git hub)
}
git_help () 
{ 
    cgit help $*;
    sfg git_ | sed 's/^/    /'
}
git_untracked () 
{ 
    cgit status | sed '1,/Untracked files:/d; s/^#[     ]*//' | tail +3
}
git_needadd () 
{ 
    git status | grep '^[       ][      ]*' | egrep -v '(:|\))'
}
git () 
{ 
    : if its NOT a function, ,then its a GIT Command;
    : the default command is STATUS, unless you can think of another;
    set -- ${*:-status};
    local gfun=git_${1};
    isfunction $gfun && { 
        $gfun ${*:2};
        return $?
    };
    cgit $*
}
git_local () 
{ 
    [[ -d .git ]] && return $?;
    [[ -d ../.git ]] || return $?;
    pushd ..
}
git_addorigin () 
{ 
    : add a remote REPO to a local REPO;
    : date: 2020-05-03;
    report_notdirectory .git && return 1;
    cgit remote add $(git_origin) $(git_url);
    comment OBSOLESCENT in behalf of git_remote
}
git_url () 
{ 
    : the directory-dependent URL;
    report_notdirectory .git && { 
        echo /dev/null;
        return 1
    };
    ${*:-echo} https://github.com/$(git_account)/$(basename $PWD)
}
git_origin () 
{ 
    : a GIT ORIGIN should be tied to the directory being served.;
    : why? git remote -v lists all ones remote REPOs. all going different places;
    : why would the "origin" be treated as a universal? No, it is a VARIABLE.;
    : date: 2020-05-03;
    report_notdirectory .git && return 1;
    set -- $(basename $PWD);
    echo ${1:0:5};
    comment OBSOLESCENT in behalf of git_repo
}
git_remote () 
{ 
    : addresses the linguistic shortfall of ORIGIN;
    : date: 2020-05-03;
    git_addorigin
}
remote_repo () 
{ 
    : addresses the linguistic shortfall of ORIGIN;
    : and here we are capitualting for expedience;
    : date: 2020-05-03;
    : date: 2020-08-20 -- capitualtion;
    : set NoWAY;
    report_notdirectory .git && return 1;
    echo origin;
    return;
    : save these for a recovery exercise?!;
    set -- $(basename $PWD);
    echo ${1:0:5}
}
cgit () 
{ 
    : date: 2020-05-03;
    command git $@
}
git_toio () 
{ 
    : date: 2020-05-03;
    git status | grep 'nothing to commit' && return;
    git add index.html;
    git add TTGL/index.html;
    git add shelf/index.html;
    git add reading/index.html;
    git commit -m "${1:-(iso_ymd)}";
    git push
}
git_diff () 
{ 
    : date: 2020-04-05;
    : date: 2020-05-11;
    set -- ${1:-cached};
    cgit diff --$1 | tee .$1.out;
    wc .$1.out
}
git_files () 
{ 
    : date: 2020-04-05;
    : date: 2020-05-11;
    ${*:-echo} $(git ls-files)
}
git_location () 
{ 
    : [go to] the Git REPO base directory;
    : date: 2020-02-26;
    : date: 2020-05-11;
    ${*:-pushd} /Users/martymcgowan/git/bapp;
    cdx
}
git_open () 
{ 
    : date: 2020-08-22;
    ${*:-open} https://${PWD#*git/}
}
git_sum () 
{ 
    : date: 2020-05-11;
    set $HOME/lib/git_sum.{txt,nxt};
    [[ -f $1 ]] || { 
        touch $1
    };
    { 
        cat $1 <(gh git | awk '$2 ~ /git/ && !p[$3,$4,$5]++' )
    } | sort -u > $2;
    echo $*
}
git_tocommit () 
{ 
    : which files may be committed;
    : date: 2020-05-11;
    git status | awk '

        /commit:/             { follow = 0};
	/committed:/          { follow = 1 };
	follow && /modified:/ { print $2 }
    '
}
git_tostage () 
{ 
    : which files may be staged;
    : date: 2020-05-11;
    git status | awk '

        /commit:/             { follow = 1 }
	follow && /modified:/ { print $2 }
    '
}
twoColumnTiddly () 
{ 
    : convert an rdb table into a 2-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    tawk '
    
    NR == 1 { printf "| !%s | !%s |\n", $1, $2}
     NR < 3 { next };
            { printf "|%s |[[%s]] |\n", $1, $2}
   '
}
threeColumnTiddly () 
{ 
    : convert an rdb table into a 3-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    tawk '
    
    NR == 1 { printf "| !%s | !%s | !%s |\n", $1, $2, $3}
     NR < 3 { next };
            { printf "|%s |%s |%s |\n", $1, $2, $3}
   '
}
fourColumnTiddly () 
{ 
    : convert an rdb table into a 4-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    tawk '
    
    NR == 1 { printf "| !%s | !%s | !%s | !%s |\n", $1, $2, $3, $4}
     NR < 3 { next };
            { printf "|%s |%s |%s |%s |\n", $1, $2, $3, $4 }
   '
}
fiveColumnTiddly () 
{ 
    : convert an rdb table into a 5-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    tawk '
    
    NR == 1 { printf "| !%s | !%s | !%s | !%s | !%s |\n", $1, $2, $3, $4, $5}
     NR < 3 { next };
            { printf "|%s |%s |%s |%s |%s |\n", $1, $2, $3, $4, $5 }
   '
}
toMIWreading () 
{ 
    : convert the reading list into the MyIdeaWarehouse format,;
    : date: 2020-07-04;
    report_notfile librarything.rdb && return 1
    sorttable -r < librarything.rdb | _rh_linkify
}
wiki_tablereport () 
{ 
    : convert the reading list into the MyIdeaWarehouse format,;
    : date: 2020-07-04;
    sorttable < tables.rdb | fourColumnTiddly
}
days_reading () 
{ 
    : a days -- todays -- reading;
    : date: 2020-07-10;
    report_notfile librarything.rdb && return 1
    zcat .hry/librarything.rdb.Z | rd grep ${1:-$(yymmdd)} | sorttable
}
read_cycle () 
{ 
    : produce RDB Table of the Reader Cycle BookKeys by Day number;
    : date: 2020-07-11;
    rdb_hdr daynum bookkeys;
    tail +3 cycle.rdb | awk '
    BEGIN { ncombo = 1; }
    NF > 1 {
            # Better: ncombo = smallest common factor of each rows count
            ncombo *= ( NF - 1 )
            cycle[$1] = $1 
            nx[$1] = $2;
            for(i=2; i < NF; i++) {

                nx[$i] = $(i+1);
  	    }
            nx[$NF] = $2;
        }
    END {
         fmtp = "\t\t\t\t%s[%s] = %s\n"
         for (i in cycle) { printf fmtp, "cycle", i, cycle[i] > /dev/stderr; }
         for (n in nx)    { printf fmtp, "nx",    n, nx[n]    > /dev/stderr; }

	 for( i = 1; i <= ncombo; i++) {
            sp = sprintf("%3d\t", i);
            for (c in cycle) { 
	        cc = cycle[c]
                # printf fmtp, "cycle", c, cc       > /dev/stderr
                # printf fmtp, "nx",   cc, nx[cc]   > /dev/stderr
		cycle[c] = nx[cc]
                printf "%s", sp nx[cc]
	        sp = " "
	    }
	    printf "\n"
        }
    }
    '
}
dayone_two () 
{ 
    : date: 2020-07-11;
    row "daynum == $1 || daynum ==$2" < readcycle.rdb | column bookkeys | headoff | wpl
}
keysmatch () 
{ 
    : date: 2020-07-11;
    rowhas key $1 < keybook.rdb | headoff
}
booksfrom () 
{ 
    : date: 2020-07-11;
    rdb_hdr key book;
    foreach keysmatch $(dayone_two $*)
}
read_twodays () 
{ 
    : date: 2020-07-11;
    set -- ${1:-6};
    set $1 $(expr $1 + 1);
    booksfrom $* | rowhas key '[A-Z]'
}
rawtsv_tordb () 
{ 
    rdb_hdr $(sed 1q $1 | sed 's/ /_/g' | lc);
    tail +2 $1
}
field_tolc () 
{ 
    report_notpipe && return 1;
    compute "$1 = tolower($1)"
}
field_xref () 
{ 
    : convert book_id field to field book_id, where field is multi-valued;
    newest $2.rdb $1 || { 
        cat $1 | column book_id $2 | headoff | rdb_n2one $2 book_id > $2.rdb
    }
}
goodfields () 
{ 
    : the field list must be trimmed. it seems 49 fields is too many for compute, etc...;
    ${*:-echo} tags collections lc_classification book_id title primary_author copies source entry_date from_where page_count lccn acquired date_{started,read} isbn{,s} subjects dewey_decimal lending_{start,end} review rating
}
lower_canon () 
{ 
    report_notfile haveread.tsv && return 1;
    rawtsv_tordb haveread.tsv | goodfields column | compute '

        tags = tolower(tags)
        collectionss = tolower(collections)	
    '
}
book_tordb () 
{ 
    : date: 2020-07-18;
    set -- ${1:-haveread.tsv};
    set -- ${1%.tsv}.rdb $1;
    report_notfile $1 && return 1;
    newest $1 $2 || { 
        lower_canon $2 > $1
    };
    field_xref $1 tags;
    field_xref $1 collections;
    newest $3 $1 || { 
        cat $1 | column book_id primary_author title rating date_{started,read} | tdb | compute '

        t=title ":"
	l=index(t,":")-1
	if (l>48) {
	    l = 48
	}
	title = substr(t,1,l)

    ' > $3
    };
    table_report
}
tdb () 
{ 
    : date: 2020-07-18;
    sed 's/[(][^\)]*[)]//g' $*
}
rdb_n2one () 
{ 
    : date: 2020-07-18;
    report_notpipe && return 1;
    rdb_hdr $*;
    sed 's/, /	/g' | tawk '{ for(i=2; i<=NF; i++) printf "%s\t%s\n", $i, $1 }'
}
tab_count () 
{ 
    : tabulate the count of unique rows;
    : date: 2020-07-18;
    report_notpipe && return 1;
    sorttable | rduniq | sorttable -n | column Count | rename Count oc | rduniq | rename Count tabul8 oc Count
}
main () 
{ 
    book_tordb
}
date_finished () 
{ 
    : from the history, finished and date last read;
    : date: 2020-08-07;
    set -- .hry/librarything.rdb.Z;
    report_notfile $1 && return 1;
    zcat $1 | sorttable -r latest | ncolumn insert_time | select_first book | row delete_time | ncolumn delete_time
}
readhistory () 
{ 
    : active and when finished books;
    : date: 2020-08-18;
    function _rh_select () 
    {
        sorttable -r latest | select_first book | sorttable book
    };
    function _rh_finish () 
    { 
        rename latest finish | compute '

        finish = ((delete_time)? finish: "")' | ncolumn {insert,delete}_time 
    };
    report_notfile librarything.rdb && return 1
    zcat .hry/librarything.rdb.Z | _rh_select | _rh_finish | sorttable $1 | _rh_linkify
}
tiddlylink () 
{ 
    : format column to wrap with TiddlyWiki LINK syntax;
    compute "$1 = \"[[\" $1 \"]]\""
}
_rh_linkify () 
{ 
    tiddlylink author | tiddlylink book | threeColumnTiddly
}
read_books () 
{ 
    : next n { two } books to read;
    : date: 2020-08-07;
    report_notfile librarything.rdb && return 1
    sorttable < librarything.rdb | column book | headoff | sed ${1:-2}q
}
h_getold () 
{
    : example of how to retrive a history file
    set -- ${1:-5734};
    set -- $(find . -name librarything.rdb | xargs ls -lrt | grep $1 | tail -1);
    declare -f $(myname)
    return
    echo $# $*;
    report_notargcount 9 $# && return 1;
    cp $9 .;
    compress librarything.rdb
}
echo git_init 1>&2
