.. () 
{ 
    : related: func_args;
    : date: 2021-03-22;
    read_devtty $*;
    $@
}
... () 
{ 
    : related: func_args;
    : date: 2021-03-22;
    read_devtty $*;
    $@
}
args_test () 
{ 
    : testing limitation -- may QUOTED args be REFORMATTED?;
    : related: func_args;
    return
}
author_lnfn () 
{ 
    : turn AUTHOR = Lname, Fname;
    : date: 2021-03-21;
    : date: 2021-03-22;
    report_notpipe && return 1;
    addcol ln fn | compute '

        ln=author; sub(/.* /,"",ln); 
	fn=author; sub(/ [^ ]*$/,"",fn);
	author = ln ", " fn
    ' | ncolumn ln fn
}
book () 
{ 
    app_isa $* || return
}
bookCollection () 
{ 
    : split out collections into a COLLECTION field;
    : date: 2021-03-22;
    cat $(readSummary) |
    .. column book_id collection collections | tawk '

        NR < 3 { print; next; }
	NR > 6 { exit; }
	       {
	         n = split($2,collection,", ");

		 for(i=1;i<n;i++) {

		   printf "%d\t%s\n", $1, collection[i]
		 };
	       }
       ' | ncolumn collections | mytable $@
}
book_author () 
{ 
    : return author, book of matching books;
    : date: 2020-11-27;
    set -- author_book.rdb "$1";
    report_notfile $1 && return 1;
    [[ -z "$2" ]] && { 
        column book < $1 | headoff;
        return
    };
    cat $1 | row "book ~ /$2/"
}
book_onehistory () 
{ 
    : date, page read by book;
    : date: 2020-12-24;
    report_notargcount 1 $# && { 
        book_list | headoff | pr -t -2;
        return 1
    };
    table_history book_page.rdb | ncolumn delete_time |
    ... rdb_iDate | row "book ~ /$1/" | title_fold |
    ... ... column i_date page book | sorttable
}
book_list () 
{ 
    : column table of the books;
    table_history book_page.rdb | column book | title_fold | sorttable -u
}
book_tordb () 
{ 
    : date: 2020-07-18;
    set -- ${1:-haveread.tsv};
    set -- ${1%.tsv}.rdb $1;
    report_notfile $1 && return 1;
    newest $1 $2 || { 
        lower_canon $2 > $1
    };
    field_xref $1 tags;
    field_xref $1 collections;
    newest $3 $1 || { 
        cat $1 | column book_id primary_author title rating date_{started,read} |
    ... tdb | compute '

        t=title ":"
	l=index(t,":")-1
	if (l>48) {
	    l = 48
	}
	title = substr(t,1,l)

    ' > $3
    };
    table_report
}
cgit () 
{ 
    : date: 2020-05-03;
    read_devtty $#, $@;
    command git $@
}
column () 
{ 
    : PROJECT columns from named RDB -- first Row -- FIELDS;
    : reads STDIN for RDB list or TABLE format,;
    : date: 2019-07-02;
    : date: 2019-08-14 added the BLANK columns, not yet in table;
    : date: 2020-05-17 RCAT replaces CAT;
    : -------------------------------------- begin template.fun --;
    local HEAD;
    local DASH;
    local COL="";
    local C;
    :;
    : read_devtty $*;
    read HEAD;
    [[ -z "$HEAD" ]] && { 
        ( echo;
        rcat ) | listtotable | $(myname) "$@" | tabletolist;
        return 0
    };
    read DASH;
    : ---------------------------------------- end template.fun --;
    : default to HEADER fields;
    set -- ${@:-$HEAD};
    for ARG in $@;
    do
        case " $HEAD " in 
            *$ARG*)
                : the column is in the table, what number?;
                (( C = 1 ));
                for I in $HEAD;
                do
                    [[ "$I" = "$ARG" ]] && { 
                        COL="${COL},\$$C"
                    };
                    (( C += 1 ));
                done
            ;;
            *)
                : the column is NOT in the table;
                COL="${COL},blank"
            ;;
        esac;
    done;
    COL=${COL#,};
    : read_devtty COL: $COL;
    rdb_hdr $@;
    rcat | awk "BEGIN { FS = OFS = \"\t\"; blank = \"""\"; }; { print $COL; }"
}
datedRecords () 
{ 
    : pull DATED current records from a history file;
    : optionally RENAME the insert date,;
    : date: 2020-11-27;
    row '!delete_time' | rdb_iDate | rename i_date ${1:-i_date} |
    ... ncolumn {insert,delete}_time
}
days_reading () 
{ 
    : a days -- todays -- reading;
    read_history | rd grep ${1:-$(yymmdd)} | sorttable
}
declare () 
{ 
    : insert ... syntactic sugar into shell functions;
    : date: 2021-01-03;
    : date: 2021-03-09 the BUG was in FUNC_ARGS;
    case $1 in 
        -f)
            shift;
            read_devtty A: $#, $@;
            echo $@ | tpl > .dot.a;
            : test for function names;
            set -- $(func_args $@);
            read_devtty B: $#, $@;
            echo $@ | tpl > .dot.b;
            [[ $# -lt 1 ]] && return 1;
            :;
            : there are some, proceed;
            command declare -f $@ | fold_pipedots
        ;;
        *)
            read_devtty D: $#, $@;
            command declare $@
        ;;
    esac
}
declare_test () 
{ 
    : date: 2021-01-03;
    ignore pushd $HOME/Dropbox/git/applemcg.github.io/reading;
    local format="\n%s\n==============================================\n";
    :;
    printf $format UTILITIES;
    declare -f func_args ... .. args_test fold_pipedots declare{,_test};
    :;
    printf $format "BEFORE - declare builtin";
    command declare -f latestbook readhistory;
    :;
    printf $format "AFTER - declare Function";
    declare -f latestbook readhistory
}
dotfunctions () 
{ 
    : functions having, or aware of a leading "." in the name;
    read_devtty $*;
    ${*:-echo} $(sfg ^[.]) sfg functions declare
}
field_tolc () 
{ 
    : convert a field to lower case;
    : related: rdb;
    report_notpipe && return 1;
    compute "$1 = tolower($1)"
}
field_xref () 
{ 
    : convert book_id field to field book_id, where field is multi-valued;
    newest $2.rdb $1 || { 
        cat $1 | column book_id $2 | headoff |
    ... rdb_n2one $2 book_id > $2.rdb
    }
}
findClean () 
{ 
    grep "$1" - | sed "s/.*$1 *//"
}
fiveColumnTiddly () 
{ 
    : convert an rdb table into a 5-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    tawk '
    
    NR == 1 { printf "| !%s | !%s | !%s | !%s | !%s |\n", $1, $2, $3, $4, $5}
     NR < 3 { next };
            { printf "|%s |%s |%s |%s |%s |\n", $1, $2, $3, $4, $5 }
   '
}
fold_pipedots () 
{ 
    : RE folds line with PIPE followed by ... s;
    : the RE allows zero or more spaces after the Pipe Symbol;
    : .. a Dot followed by zero or more Dots or Spaces,;
    : .. closed by a space, which separates .s from the command;
    sed '
        s/| *\([.][. ]*\) /|\
    \1 /g'
}
fourColumnTiddly () 
{ 
    : convert an rdb table into a 4-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    sed 's/|/\&#124;/g' | tawk '        
    BEGIN   { left = "|%s "
              rite = "| %s"
	      line = "|\n"
              defl = left left left left line
	    }
    NR == 1 { printf "| !%s | !%s | !%s | !%s |\n", $1, $2, $3, $4}
     NR < 3 { next };
            { printf defl, $1, $2, $3, $4 }
   '
}
fun_column () 
{ 
    : collect one of columns in from the function table;
    : date: 2021-01-18;
    local file=shd_alldata.lst;
    if_missingargs 1 $@ && { 
        printfirst < $file;
        return 1
    };
    cat $file | awk "\$1 ~ /fun/ || NF < 1 || \$1 ~ /$1/" |
    ... column fun $1 | listtotable | row $1
}
func_args () 
{ 
    : use TYPE to simulate declare -f;
    : Thou Shalt NOT sort!;
    : date: 2021-03-09 much more explict TYPE -A test in AWK;
    type -a ${@:-/dev/null} 2> /dev/null | tee .dot.0 | awk '
        $2$3$4 ~ /isafunction/ && \
	$1 ~ /^[.a-zA-Z0-9][.a-zA-Z0-9_]*$/ { print $1 }
    '
}
git () 
{ 
    : if its NOT a function, ,then its a GIT Command;
    : the default command is STATUS, unless you can think of another;
    set -- ${*:-status};
    local gfun=git_${1};
    read_devtty gfun: $gfun;
    isfunction $gfun && { 
        $gfun ${*:2};
        return $?
    };
    cgit $*
}
git_account () 
{ 
    : set or return the account name of;
    case $# in 
        0)
            echo ${GIT_ACCOUNT}
        ;;
        *)
            setenv GIT_ACCOUNT $1
        ;;
    esac
}
git_add () 
{ 
    cgit add "$@"
}
git_addorigin () 
{ 
    : add a remote REPO to a local REPO;
    : date: 2020-05-03;
    report_notdirectory .git && return 1;
    cgit remote add $(git_origin) $(git_url);
    comment OBSOLESCENT in behalf of git_remote
}
git_clone () 
{ 
    indir .. cgit clone $(git hub)
}
git_deleted () 
{ 
    cgit status | grep deleted: | field 2
}
git_diff () 
{ 
    : date: 2020-04-05;
    : date: 2020-05-11;
    set -- ${1:-cached};
    cgit diff --$1 | tee .$1.out;
    wc .$1.out
}
git_files () 
{ 
    : date: 2020-04-05;
    : date: 2020-05-11;
    ${*:-echo} $(git ls-files)
}
git_help () 
{ 
    cgit help $*;
    sfg git_ | sed 's/^/    /'
}
git_hub () 
{ 
    mygithub https://
}
git_init () 
{ 
    : when this becomes and APP, may be overridden;
    : by defining a git_user, which in the App World,;
    : is invoked _after_ any _init function;
    git_account applemcg;
    comment main;
    git_rdfun
}
git_local () 
{ 
    [[ -d .git ]] && return $?;
    [[ -d ../.git ]] || return $?;
    pushd ..
}
git_location () 
{ 
    : [go to] the Git REPO base directory;
    : date: 2020-02-26;
    : date: 2020-05-11;
    ${*:-pushd} /Users/martymcgowan/git/bapp;
    cdx
}
git_modified () 
{ 
    : list the modified GIT files;
    : date: 2020-07-27;
    git status | awk '$1 ~ /modified:/ { print $2 }'
}
git_mods () 
{ 
    cgit status | findClean modified:;
    git status | findClean "new file:"
}
git_name () 
{ 
    ignore pushd .;
    while [[ $PWD != "/" ]]; do
        [[ -d .git ]] && { 
            basename $PWD;
            break
        };
        cd ..;
    done;
    ignore popd
}
git_needadd () 
{ 
    git status | grep '^[       ][      ]*' | egrep -v '(:|\))'
}
git_open () 
{ 
    : date: 2020-08-22;
    ${*:-open} https://${PWD#*git/}
}
git_origin () 
{ 
    : a GIT ORIGIN should be tied to the directory being served.;
    : why? git remote -v lists all ones remote REPOs. all going different places;
    : why would the "origin" be treated as a universal? No, it is a VARIABLE.;
    : date: 2020-05-03;
    report_notdirectory .git && return 1;
    set -- $(basename $PWD);
    echo ${1:0:5};
    comment OBSOLESCENT in behalf of git_repo
}
git_pullclone () 
{ 
    [[ -e $1 ]] && { 
        comment Fetching master latest pull for: $2;
        ignore pushd $1;
        cgit pull;
        ignore popd
    } || { 
        comment Cloning $2;
        cgit clone $2
    }
}
git_push () 
{ 
    : to remember the origin;
    : date: 2020-03-28;
    comment cgit push $(remote_repo) ${1:-master};
    cgit push $(remote_repo) ${1:-master}
}
git_rdfun () 
{ 
    ${*:-echo} $(myname) keysmatch field_tolc field_xref lower_canon book_tordb tab_count onMyNightstand book_author
}
git_remote () 
{ 
    : addresses the linguistic shortfall of ORIGIN;
    : date: 2020-05-03;
    git_addorigin
}
git_ssh () 
{ 
    mygithub git@
}
git_status () 
{ 
    read_devtty $#, $@;
    cgit status
}
git_sum () 
{ 
    : date: 2020-05-11;
    set $HOME/lib/git_sum.{txt,nxt};
    [[ -f $1 ]] || { 
        touch $1
    };
    { 
        cat $1 <(gh git | awk '$2 ~ /git/ && !p[$3,$4,$5]++' )
    } | sort -u > $2;
    echo $*
}
git_tocommit () 
{ 
    : which files may be committed;
    : date: 2020-05-11;
    git status | awk '

        /commit:/             { follow = 0};
	/committed:/          { follow = 1 };
	follow && /modified:/ { print $2 }
    '
}
git_toio () 
{ 
    : date: 2020-05-03;
    git status | grep 'nothing to commit' && return;
    git add index.html;
    git add TTGL/index.html;
    git add shelf/index.html;
    git add reading/index.html;
    git commit -m "${1:-(iso_ymd)}";
    git push
}
git_tostage () 
{ 
    : which files may be staged;
    : date: 2020-05-11;
    git status | awk '

        /commit:/             { follow = 1 }
	follow && /modified:/ { print $2 }
    '
}
git_untracked () 
{ 
    cgit status | sed '1,/Untracked files:/d; s/^#[     ]*//' |
    ... tail +${1:-2}
}
git_url () 
{ 
    : the directory-dependent URL;
    report_notdirectory .git && { 
        echo /dev/null;
        return 1
    };
    ${*:-echo} https://github.com/$(git_account)/$(basename $PWD)
}
gitlib_copyright () 
{ 
    cat  <<EOF

Copyright (c)2 2015-2021 Marty McGowan, JYATL - Just Yet Another Testing Lab

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

EOF

}
gitlib_version () 
{ 
    printf "%s\t%s\n" gitlib 0.5.0
}
goodfields () 
{ 
    : the field list must be trimmed. it seems 49 fields is too many for compute, etc...;
    ${*:-echo} tags collections lc_classification book_id title primary_author copies source entry_date from_where page_count lccn acquired date_{started,read} isbn{,s} subjects dewey_decimal lending_{start,end} review rating
}
h_getold () 
{ 
    : example of how to retrive a history file;
    set -- ${1:-5734};
    set -- $(find . -name librarything.rdb | xargs ls -lrt |
    ... grep $1 | tail -1);
    declare -f $(myname);
    return;
    echo $# $*;
    report_notargcount 9 $# && return 1;
    cp $9 .;
    compress librarything.rdb
}
i_timeDate () 
{ 
    : date: 2020-12-05;
    row '!delete_time' | rdb_iDate |
    ... rename i_date ${1:-i_date} | ncolumn {insert,delete}_time
}
jointable () 
{ 
    : join two tables into one where keys match;
    : for historic compatibility, -jN is preserved, and;
    : uses join with -j N;
    : todo: "sort" out leading column name;
    : date: 2017-03-26;
    : date: 2020-04-11;
    local COLS="";
    local ARGS="";
    local f1="";
    local f2="";
    local tmp=$HOME/tmp/$(myname);
    rm -f $tmp.*;
    while [ $# -gt 0 ]; do
        arg=$1;
        shift;
        case $arg in 
            -)
                if [ -z "$f1" ]; then
                    cat - > $tmp.i;
                    f1=$tmp.i;
                else
                    cat - > $tmp.i;
                    f2=$tmp.i;
                fi;
                read_devtty stdin, f1, f2: $arg, $f1, $f2
            ;;
            -t)
                : ignore the T, apply after args are parsed;
                continue
            ;;
            -j1 | -1)
                local j1=$1;
                shift
            ;;
            -j2 | -2)
                local j2=$1;
                shift
            ;;
            -[aoj])
                : ignore these
            ;;
            -[ve12])
                ARGS="$ARGS $arg $1";
                shift
            ;;
            -*)
                ARGS="$ARGS $arg"
            ;;
            *)
                read_devtty file?, f1, f2: $arg, $f1, $f2;
                : column names or file args;
                if [ ! -f $arg ]; then
                    COLS="$COLS $arg";
                    :;
                else
                    if [ -z "$f1" ]; then
                        f1=$arg;
                        :;
                    else
                        if [ -z "$f2" ]; then
                            f2=$arg;
                        fi;
                    fi;
                fi
            ;;
        esac;
        read_devtty arg, f1, f2: $arg, $f1, $f2;
    done;
    [[ -z "$f2" ]] && { 
        : there was no table 2, is it on STDIN;
        [[ "$f1" = "$tmp.i" ]] && { 
            comment bad STDIN or missing FILE $arg;
            return 3
        };
        f2=$tmp.i;
        cat - > $f2
    };
    read_devtty last f1, f2: $f1, $f2;
    report_notfile $f1 && return 1;
    report_notfile $f2 && return 2;
    : --------------------------------------------------- clean up args --;
    :;
    : ---------------------------- multi-arg resolution --;
    :;
    [[ -n "$j1" ]] && { 
        ARGS="$ARGS -1 $(rdb_column $f1 $j1)"
    };
    [[ -n "$j2" ]] && { 
        ARGS="$ARGS -2 $(rdb_column $f2 $j2)"
    };
    read_devtty ARGS: $ARGS;
    :;
    : ---------------- TAB is the only field separator --;
    : and requires the EVAL in the join command;
    :;
    : date: 2020-09-08 in which i learned this bash syntax;
    : ref: "https://duckduckgo.com/?t=ffab&q=bash+join+tab";
    ARGS="$ARGS -t $'\t'";
    : --------------------------------------------- collect the columns --;
    :;
    local COL1=$(sed 1q $f1);
    local COL2=$(sed 1q $f2);
    :;
    read_devtty FILE: $f1, COLUMNS: $COL1;
    cat $f1 | column $COL1 | sorttable -u $j1 | headoff > $tmp.a;
    :;
    read_devtty FILE: $f2, COLUMNS: $COL2;
    cat $f2 | column $COL2 | sorttable -u $j2 | headoff > $tmp.b;
    :;
    : columns of the JOINed table;
    set -- $(args_uniq $j1 $j2 $COL1 $COL2);
    read_devtty rdb_hdr $*;
    rdb_hdr $*;
    read_devtty join $ARGS $tmp.{a,b};
    : the EVAL is mandated by the TAB syntax;
    echo "join $ARGS $tmp.{a,b}" > ${tmp}.err;
    eval join $ARGS $tmp.{a,b}
}
keysmatch () 
{ 
    : date: 2020-07-11;
    rowhas key $1 < keybook.rdb | headoff
}
latest_gitfunctions () 
{ 
    : date: 2021-02-15;
    latestfunctions gitlib;
    return
}
latestbook () 
{ 
    : date: 2020-12-05;
    cat $(latestbookpage) | column latest page author book | mytable $@
}
latestbookpage () 
{ 
    : all reading history with author and book;
    : date: 2021-03-04 save intermediate lat;
    table_history book_page.rdb | i_timeDate latest |
    .. jointable -1 book -2 book - author_book.rdb | mytable $@
}
link_authorBook () 
{ 
    : date: 2020-12-05;
    report_notpipe && return 1;
    set -- ${1:-four};
    tiddlylink author book | ${1}ColumnTiddly | show_tmpclip
}
lname_sort () 
{ 
    : oblsolescent:;
    : date: 2021-03-21;
    cat author_book.rdb | addcol lname | compute '

        lname = author;
	sub(/.* /,"",lname)
    ' | sorttable lname | ncolumn lname | justify
}
lower_canon () 
{ 
    : translate any collection name to lower_case;
    runfrom $(applemcg echo)/reading || return;
    report_notfile haveread.tsv && return 1;
    rawtsv_tordb haveread.tsv | goodfields column | compute '
    
        tags = tolower(tags)
        collections = tolower(collections)	
    '
}
main () 
{ 
    book_tordb
}
mygithub () 
{ 
    case $1 in 
        *@)
            separator=":"
        ;;
        *//)
            separator="/"
        ;;
    esac;
    echo ${1}github.com${separator}$(git_account)/$(basename $PWD).git
}
mytable () 
{ 
    : create an RDB table with name of the calling function, echoing the table Name;
    : related: dotfunctions;
    : date: 2021-02-06;
    local caller=$(myname 2);
    case $caller in 
        [.]*)
            caller=$(myname 3)
        ;;
    esac;
    read_devtty $*;
    sometable $caller
}
ncolumn () 
{ 
    : removes columns from table, "Not Column";
    : date: 2019-07-02;
    : date: 2019-08-14 added the BLANK columns, not yet in table;
    : -------------------------------------- begin template.fun --;
    : date: 2019-08-27;
    local HEAD;
    local DASH;
    local COL="";
    local C;
    :;
    read HEAD;
    [[ -z "$HEAD" ]] && { 
        ( echo;
        cat ) | listtotable | $(myname) "$@" | tabletolist;
        return 0
    };
    read DASH;
    : ---------------------------------------- end template.fun --;
    : extract names from HEADER fields;
    COL=$(echo :$HEAD: | tr ' 	' :);
    : app_trace COL: $COL;
    for C in $@;
    do
        COL=${COL/:$C:/:};
        : app_trace removed $C, COL: $COL;
    done;
    COL=$(echo $COL | tr : ' ');
    : app_trace ARGS: $*;
    : app_trace HEAD: $HEAD;
    : app_trace COL: $COL;
    ( rdb_hdr $HEAD;
    cat ) | column $COL
}
obs_tiddlylink () 
{ 
    : format column to wrap with TiddlyWiki LINK syntax;
    compute "$1 = \"[[\" $1 \"]]\""
}
onMyNightstand () 
{ 
    : date: 2020-12-05;
    : date: 2021-01-03;
    runfrom $(reading) || return;
    cat $(latestbook) | sorttable | link_authorBook
}
pick () 
{ 
    : ~ arg ...;
    : add positive replies to STDOUT;
    : y -- add to output;
    : Y -- add to output and Quit;
    : q -- Quit;
    : * -- ignore;
    : fm Kernighan and Pike, Unix Programming Enviroment, 1984;
    : date: 2018-06-22;
    :;
    for a in $*;
    do
        printf "%s\t?: " "$a" > /dev/tty;
        read response < /dev/tty;
        case $response in 
            y*)
                echo "$a" | field 1
            ;;
            Y*)
                echo "$a" | field 1;
                break
            ;;
            q*)
                break
            ;;
            *)

            ;;
        esac;
    done
}
pipe_myargs () 
{ 
    : pipe each arg through successive pipes;
    : date: 2021-02-28;
    if_missingargs 2 $* && return 1;
    local caller=$(myname 2);
    $caller $1 | $caller ${*:2}
}
rawtsv_tordb () 
{ 
    : pick a file from the list of TSVs, write a HDR as a TABLE;
    set -- ${1:-$(pick *.tsv /dev/null)};
    set -- $1 ${1%*.tsv}.tmp;
    report_notfile $1 && return 1;
    fmdos $1 > $2;
    rdb_hdr $(sed 1q $2 | sed 's/ /_/g' | lc);
    tail +2 $2
}
rdb_iDate () 
{ 
    : convert INSERT_TIME into I_DATE;
    : date: 2019-06-11;
    addcol i_date | compute 'i_date = substr(insert_time,1,6)'
}
rdb_n2one () 
{ 
    : date: 2020-07-18;
    report_notpipe && return 1;
    rdb_hdr $*;
    sed 's/, /	/g' |
    ... tawk '{ for(i=2; i<=NF; i++) printf "%s\t%s\n", $i, $1 }'
}
remote_repo () 
{ 
    : addresses the linguistic shortfall of ORIGIN;
    : and here we are capitualting for expedience;
    : date: 2020-05-03;
    : date: 2020-08-20 -- capitualtion;
    : set NoWAY;
    report_notdirectory .git && return 1;
    echo origin;
    return;
    : save these for a recovery exercise?!;
    set -- $(basename $PWD);
    echo ${1:0:5}
}
rename () 
{ 
    : ~ fromFieldName toNewName ...;
    : by modifying the matching column name;
    : date: 2016-11-15;
    : date: 2019-08-14;
    report_notpipe && return 1;
    : -------------------------------------- begin template.fun --;
    local HEAD;
    local DASH;
    :;
    read HEAD;
    [[ -z "$HEAD" ]] && { 
        ( echo;
        rcat ) | listtotable | $(myname) "$@" | tabletolist;
        return 0
    };
    read DASH;
    : ---------------------------------------- end template.fun --;
    HEAD=$(echo :$HEAD: | tr ' 	' :);
    while [[ $# -gt 1 ]]; do
        HEAD=${HEAD/:$1:/:$2:};
        shift 2;
    done;
    HEAD=$(echo $HEAD | tr : ' ');
    rdb_hdr $HEAD;
    cat
}
replace () 
{ 
    [[ $# -lt 2 ]] && { 
        cat ${*:--};
        return
    };
    sed "s/$1/$2/g" $*
}
select_first () 
{ 
    : select the first occurrence of a fields value;
    : since "$1" in this context is the argument to this function,;
    : a column name, and NOT a awk positional paramter. this function;
    : started life with a "gem" tag, but thought better to call a "lesson"!;
    : this is the GEM of the DAY;
    : ref: needs a URL on th shelf w.r.t why such a gem;
    : date: 2020-05-08;
    : date: 2020-11-14;
    report_notpipe && { 
        cat -;
        return 1
    };
    report_notargcount 1 $# && { 
        cat -;
        return 2
    };
    row "!selected[$1]++"
}
show_tmpclip () 
{ 
    : display the pipe on the tty, save in a TMPfile, and the CLIPBOARD;
    : date: 2021-02-27;
    report_notpipe && return 1;
    tee /dev/tty | tee .$(myname 2).tmp | pbcopy
}
sorttable () 
{ 
    : sort /RDB table according to books p. 398;
    : single lettter with following arg TkSo;
    : todo: accomodate field NAMES;
    : date: 2020-04-11;
    : simple rd sort $*;
    read HEAD;
    [[ -z "$HEAD" ]] && { 
        ( echo;
        cat ) | listtotable | sorttable "$@" | tabletolist;
        return 0
    };
    read DASH;
    : sort -t ...;
    ARGS="";
    while [ -n "$1" ]; do
        case $1 in 
            --*)
                : eschew or IGNORE -- args;
                continue
            ;;
            -t)
                : -t is a TAB, none other;
                continue
            ;;
            -[koST])
                : allow -k N args, prefer Column Name;
                ARGS="$ARGS $1 $2";
                shift
            ;;
            -*)
                ARGS="$ARGS $1"
            ;;
            *)
                : detect Column Name;
                local argn=$(argnumber $1 $HEAD);
                [[ $argn == 0 ]] && continue;
                ARGS="$ARGS -k $argn"
            ;;
        esac;
        shift;
    done;
    rdb_hdr $HEAD;
    sort -t'	' $ARGS
}
subcmmd () 
{ 
    grep '^ *[a-z[a-z]*)$' | sed 's/)$//; s/ */git /' $*
}
tab_count () 
{ 
    : tabulate the count of unique rows;
    : date: 2020-07-18;
    report_notpipe && return 1;
    sorttable | rduniq | sorttable -n | column Count |
    ... rename Count oc | rduniq | rename Count tabul8 oc Count
}
table_history () 
{ 
    report_notfile ${1:-/dev/null} && { 
        sleep 5;
        comment "[CR]";
        return 1
    };
    rdb_canon $1;
    zcat .hry/$1.Z
}
tawk () 
{ 
    : date: 2017-07-10;
    : date: 2017-07-18;
    : app_trace $# "$@";
    awk -F'\t' "$@"
}
tdb () 
{ 
    : date: 2020-07-18;
    sed 's/[(][^\)]*[)]//g' $*
}
threeColumnTiddly () 
{ 
    : convert an rdb table into a 3-column tiddly table;
    : and since the pipe is part of the table, then;
    : replace actual pipes with their character code;
    : date: 2020-07-04;
    : date: 2020-10-22;
    report_notpipe && return 1;
    sed 's/|/\&#124;/g' | tawk '
    
    NR == 1 { printf "| !%s | !%s | !%s |\n", $1, $2, $3}
     NR < 3 { next };
            { printf "|%s |%s |%s |\n", $1, $2, $3}
   '
}
tiddlylink () 
{ 
    : wrap each named data field with TiddlyWiki LINK syntax;
    : todo: generalize the feature on the 3rd implementation;
    : related: obs_tiddlylink;
    : date: 2021-02-27;
    if_missingargs 1 $* && return 1;
    case $# in 
        1)
            report_notpipe && return 1;
            compute "$1 = \"[[\" $1 \"]]\""
        ;;
        *)
            pipe_myargs $*
        ;;
    esac;
    return;
    comment $(myname) $1 PIPE $(myname) ${*:2}
}
tiddlylink_test () 
{ 
    : multi- and single-link reports;
    : date: 2021-02-27;
    onMyNightstand;
    read_year
}
title_fold () 
{ 
    report_notpipe && return 1;
    compute 'if( book ~ /^The /) { sub(/^The /,"",book); book = book ", The" }'
}
twoColumnTiddly () 
{ 
    : convert an rdb table into a 2-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    sed 's/|/\&#124;/g' | tawk '    
    
    NR == 1 { printf "| !%s | !%s |\n", $1, $2}
     NR < 3 { next };
            { printf "|%s |%s |\n", $1, $2}
   '
}
wiki_tablereport () 
{ 
    : convert the reading list into the MyIdeaWarehouse format,;
    : date: 2020-07-04;
    sorttable < tables.rdb | fourColumnTiddly
}
yourtable () 
{ 
    : create an RDB table with name of the callers caller, echoing the table Name;
    : related: mytable;
    : date: 2021-02-06;
    sometable $(myname 3)
}
echo git_init 1>&2
