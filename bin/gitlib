gitlib_copyright () 
{ 
    cat <<EOF

Copyright (c)2 2015-2020 Marty McGowan, JYATL - Just Yet Another Testing Lab

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

EOF

}
gitlib_version () 
{ 
    printf "%s\t%s\n" gitlib 0.5.0
}
git_pullclone () 
{ 
    [[ -e $1 ]] && { 
        comment Fetching master latest pull for: $2;
        ignore pushd $1;
        cgit pull;
        ignore popd
    } || { 
        comment Cloning $2;
        cgit clone $2
    }
}
git_init () 
{ 
    : when this becomes and APP, may be overridden;
    : by defining a git_user, which in the App World,;
    : is invoked _after_ any _init function;
    git_account applemcg;
    comment main;
    git_rdfun
}
git_account () 
{ 
    : set or return the account name of;
    case $# in 
        0)
            echo ${GIT_ACCOUNT}
        ;;
        *)
            setenv GIT_ACCOUNT $1
        ;;
    esac
}
findClean () 
{ 
    grep "$1" - | sed "s/.*$1 *//"
}
subcmmd () 
{ 
    grep '^ *[a-z[a-z]*)$' | sed 's/)$//; s/ */git /' $*
}
mygithub () 
{ 
    case $1 in 
        *@)
            separator=":"
        ;;
        *//)
            separator="/"
        ;;
    esac;
    echo ${1}github.com${separator}$(git_account)/$(basename $PWD).git
}
git_modified () 
{ 
    : list the modified GIT files;
    : date: 2020-07-27;
    git status | awk '$1 ~ /modified:/ { print $2 }'
}
git_deleted () 
{ 
    cgit status | grep deleted: | field 2
}
git_mods () 
{ 
    cgit status | findClean modified:;
    git status | findClean "new file:"
}
git_hub () 
{ 
    mygithub https://
}
git_ssh () 
{ 
    mygithub git@
}
git_push () 
{ 
    : to remember the origin;
    : date: 2020-03-28;
    comment cgit push $(remote_repo) ${1:-master};
    cgit push $(remote_repo) ${1:-master}
}
git_add () 
{ 
    cgit add "$@"
}
git_name () 
{ 
    ignore pushd .;
    while [[ $PWD != "/" ]]; do
        [[ -d .git ]] && { 
            basename $PWD;
            break
        };
        cd ..;
    done;
    ignore popd
}
git_clone () 
{ 
    indir .. cgit clone $(git hub)
}
git_help () 
{ 
    cgit help $*;
    sfg git_ | sed 's/^/    /'
}
git_untracked () 
{ 
    cgit status | sed '1,/Untracked files:/d; s/^#[     ]*//' | tail +${1:-2}
}
git_needadd () 
{ 
    git status | grep '^[       ][      ]*' | egrep -v '(:|\))'
}
git () 
{ 
    : if its NOT a function, ,then its a GIT Command;
    : the default command is STATUS, unless you can think of another;
    set -- ${*:-status};
    local gfun=git_${1};
    isfunction $gfun && { 
        $gfun ${*:2};
        return $?
    };
    cgit $*
}
git_local () 
{ 
    [[ -d .git ]] && return $?;
    [[ -d ../.git ]] || return $?;
    pushd ..
}
git_addorigin () 
{ 
    : add a remote REPO to a local REPO;
    : date: 2020-05-03;
    report_notdirectory .git && return 1;
    cgit remote add $(git_origin) $(git_url);
    comment OBSOLESCENT in behalf of git_remote
}
git_url () 
{ 
    : the directory-dependent URL;
    report_notdirectory .git && { 
        echo /dev/null;
        return 1
    };
    ${*:-echo} https://github.com/$(git_account)/$(basename $PWD)
}
git_origin () 
{ 
    : a GIT ORIGIN should be tied to the directory being served.;
    : why? git remote -v lists all ones remote REPOs. all going different places;
    : why would the "origin" be treated as a universal? No, it is a VARIABLE.;
    : date: 2020-05-03;
    report_notdirectory .git && return 1;
    set -- $(basename $PWD);
    echo ${1:0:5};
    comment OBSOLESCENT in behalf of git_repo
}
git_remote () 
{ 
    : addresses the linguistic shortfall of ORIGIN;
    : date: 2020-05-03;
    git_addorigin
}
remote_repo () 
{ 
    : addresses the linguistic shortfall of ORIGIN;
    : and here we are capitualting for expedience;
    : date: 2020-05-03;
    : date: 2020-08-20 -- capitualtion;
    : set NoWAY;
    report_notdirectory .git && return 1;
    echo origin;
    return;
    : save these for a recovery exercise?!;
    set -- $(basename $PWD);
    echo ${1:0:5}
}
cgit () 
{ 
    : date: 2020-05-03;
    command git $@
}
git_toio () 
{ 
    : date: 2020-05-03;
    git status | grep 'nothing to commit' && return;
    git add index.html;
    git add TTGL/index.html;
    git add shelf/index.html;
    git add reading/index.html;
    git commit -m "${1:-(iso_ymd)}";
    git push
}
git_diff () 
{ 
    : date: 2020-04-05;
    : date: 2020-05-11;
    set -- ${1:-cached};
    cgit diff --$1 | tee .$1.out;
    wc .$1.out
}
git_files () 
{ 
    : date: 2020-04-05;
    : date: 2020-05-11;
    ${*:-echo} $(git ls-files)
}
git_location () 
{ 
    : [go to] the Git REPO base directory;
    : date: 2020-02-26;
    : date: 2020-05-11;
    ${*:-pushd} /Users/martymcgowan/git/bapp;
    cdx
}
git_open () 
{ 
    : date: 2020-08-22;
    ${*:-open} https://${PWD#*git/}
}
git_sum () 
{ 
    : date: 2020-05-11;
    set $HOME/lib/git_sum.{txt,nxt};
    [[ -f $1 ]] || { 
        touch $1
    };
    { 
        cat $1 <(gh git | awk '$2 ~ /git/ && !p[$3,$4,$5]++' )
    } | sort -u > $2;
    echo $*
}
git_tocommit () 
{ 
    : which files may be committed;
    : date: 2020-05-11;
    git status | awk '

        /commit:/             { follow = 0};
	/committed:/          { follow = 1 };
	follow && /modified:/ { print $2 }
    '
}
git_tostage () 
{ 
    : which files may be staged;
    : date: 2020-05-11;
    git status | awk '

        /commit:/             { follow = 1 }
	follow && /modified:/ { print $2 }
    '
}
twoColumnTiddly () 
{ 
    : convert an rdb table into a 2-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    sed 's/|/\&#124;/g' | tawk '    
    
    NR == 1 { printf "| !%s | !%s |\n", $1, $2}
     NR < 3 { next };
            { printf "|%s |%s |\n", $1, $2}
   '
}
threeColumnTiddly () 
{ 
    : convert an rdb table into a 3-column tiddly table;
    : and since the pipe is part of the table, then;
    : replace actual pipes with their character code;
    : date: 2020-07-04;
    : date: 2020-10-22;
    report_notpipe && return 1;
    sed 's/|/\&#124;/g' | tawk '
    
    NR == 1 { printf "| !%s | !%s | !%s |\n", $1, $2, $3}
     NR < 3 { next };
            { printf "|%s |%s |%s |\n", $1, $2, $3}
   '
}
fourColumnTiddly () 
{ 
    : convert an rdb table into a 4-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    sed 's/|/\&#124;/g' | tawk '        
    BEGIN   { left = "|%s "
              rite = "| %s"
	      line = "|\n"
              defl = left left left left line
	    }
    NR == 1 { printf "| !%s | !%s | !%s | !%s |\n", $1, $2, $3, $4}
     NR < 3 { next };
            { printf defl, $1, $2, $3, $4 }
   '
}
fiveColumnTiddly () 
{ 
    : convert an rdb table into a 5-column tiddly table;
    : date: 2020-07-04;
    report_notpipe && return 1;
    tawk '
    
    NR == 1 { printf "| !%s | !%s | !%s | !%s | !%s |\n", $1, $2, $3, $4, $5}
     NR < 3 { next };
            { printf "|%s |%s |%s |%s |%s |\n", $1, $2, $3, $4, $5 }
   '
}
wiki_tablereport () 
{ 
    : convert the reading list into the MyIdeaWarehouse format,;
    : date: 2020-07-04;
    sorttable < tables.rdb | fourColumnTiddly
}
days_reading () 
{ 
    : a days -- todays -- reading;
    read_history | rd grep ${1:-$(yymmdd)} | sorttable
}
read_history () 
{ 
    : update and show history;
    : date: 2020-07-10;
    table_history book_page.rdb
}
read_book () 
{ 
    : books reading history;
    if_missingargs 1 $@ && { 
        read_history | column book | sorttable | select_first book | headoff 1>&2;
        return 1
    };
    read_history | row "book ~ /$1/" | rdb_iDate | sorttable -r i_date | select_first i_date | rename i_date read | column read page | sorttable -u
}
keysmatch () 
{ 
    : date: 2020-07-11;
    rowhas key $1 < keybook.rdb | headoff
}
rawtsv_tordb () 
{ 
    : pick a file from the list of TSVs, write a HDR as a TABLE;
    set -- ${1:-$(pick *.tsv /dev/null)};
    set -- $1 ${1%*.tsv}.tmp;
    report_notfile $1 && return 1;
    fmdos $1 > $2;
    rdb_hdr $(sed 1q $2 | sed 's/ /_/g' | lc);
    tail +2 $2
}
field_tolc () 
{ 
    : convert a field to lower case;
    : related: rdb;
    report_notpipe && return 1;
    compute "$1 = tolower($1)"
}
field_xref () 
{ 
    : convert book_id field to field book_id, where field is multi-valued;
    newest $2.rdb $1 || { 
        cat $1 | column book_id $2 | headoff | rdb_n2one $2 book_id > $2.rdb
    }
}
goodfields () 
{ 
    : the field list must be trimmed. it seems 49 fields is too many for compute, etc...;
    ${*:-echo} tags collections lc_classification book_id title primary_author copies source entry_date from_where page_count lccn acquired date_{started,read} isbn{,s} subjects dewey_decimal lending_{start,end} review rating
}
lower_canon () 
{ 
    : translate any collection name to lower_case;
    runfrom $(applemcg echo)/reading || return;
    report_notfile haveread.tsv && return 1;
    rawtsv_tordb haveread.tsv | goodfields column | compute '
    
        tags = tolower(tags)
        collections = tolower(collections)	
    '
}
book_tordb () 
{ 
    : date: 2020-07-18;
    set -- ${1:-haveread.tsv};
    set -- ${1%.tsv}.rdb $1;
    report_notfile $1 && return 1;
    newest $1 $2 || { 
        lower_canon $2 > $1
    };
    field_xref $1 tags;
    field_xref $1 collections;
    newest $3 $1 || { 
        cat $1 | column book_id primary_author title rating date_{started,read} | tdb | compute '

        t=title ":"
	l=index(t,":")-1
	if (l>48) {
	    l = 48
	}
	title = substr(t,1,l)

    ' > $3
    };
    table_report
}
tdb () 
{ 
    : date: 2020-07-18;
    sed 's/[(][^\)]*[)]//g' $*
}
rdb_n2one () 
{ 
    : date: 2020-07-18;
    report_notpipe && return 1;
    rdb_hdr $*;
    sed 's/, /	/g' | tawk '{ for(i=2; i<=NF; i++) printf "%s\t%s\n", $i, $1 }'
}
tab_count () 
{ 
    : tabulate the count of unique rows;
    : date: 2020-07-18;
    report_notpipe && return 1;
    sorttable | rduniq | sorttable -n | column Count | rename Count oc | rduniq | rename Count tabul8 oc Count
}
main () 
{ 
    book_tordb
}
tiddlylink () 
{ 
    : format column to wrap with TiddlyWiki LINK syntax;
    compute "$1 = \"[[\" $1 \"]]\""
}
git_rdfun () 
{ 
    ${*:-echo} $(myname) keysmatch field_tolc field_xref lower_canon book_tordb tab_count onMyNightstand book_author
}
h_getold () 
{ 
    : example of how to retrive a history file;
    set -- ${1:-5734};
    set -- $(find . -name librarything.rdb | xargs ls -lrt | grep $1 | tail -1);
    declare -f $(myname);
    return;
    echo $# $*;
    report_notargcount 9 $# && return 1;
    cp $9 .;
    compress librarything.rdb
}
book_author () 
{ 
    : return author, book of matching books;
    : date: 2020-11-27;
    set -- author_book.rdb "$1";
    report_notfile $1 && return 1;
    [[ -z "$2" ]] && { 
        column book < $1 | headoff;
        return
    };
    cat $1 | row "book ~ /$2/"
}
datedRecords () 
{ 
    : pull DATED current records from a history file, optionally RENAME the insert date,;
    : date: 2020-11-27;
    row '!delete_time' | rdb_iDate | rename i_date ${1:-i_date} | ncolumn {insert,delete}_time
}
link_authorBook () 
{ 
    : date: 2020-12-05;
    set -- ${1:-four};
    tiddlylink author | tiddlylink book | ${1}ColumnTiddly
}
latestpageauthorbook () 
{ 
    column latest page author book | tee $(myname).rdb
}
onMyNightstand () 
{ 
    : date: 2020-12-05;
    latestbook | sorttable | link_authorBook
}
i_timeDate () 
{ 
    : date: 2020-12-05;
    row '!delete_time' | rdb_iDate | rename i_date ${1:-i_date} | ncolumn {insert,delete}_time
}
table_history () 
{ 
    report_notfile ${1:-/dev/null} && { 
        sleep 5;
        comment "[CR]";
        return 1
    };
    rdb_canon $1;
    zcat .hry/$1.Z
}
book_list () 
{ 
    : column table of the books;
    table_history book_page.rdb | column book | title_fold | sorttable -u
}
latestbook () 
{ 
    : date: 2020-12-05;
    table_history book_page.rdb | i_timeDate latest | jointable -1 book -2 book - author_book.rdb | column latest page author book | tee $(myname).rdb
}
title_fold () 
{ 
    report_notpipe && return 1;
    compute 'if( book ~ /^The /) { sub(/^The /,"",book); book = book ", The" }'
}
book_history () 
{ 
    : date, page read by book;
    : date: 2020-12-24;
    report_notargcount 1 $# && { 
        book_list | headoff | pr -t -2;
        return 1
    };
    table_history book_page.rdb | ncolumn delete_time | rdb_iDate | row "book ~ /$1/" | title_fold | column i_date page book | sorttable
}
readhistory () 
{ 
    : reading history with currentbooks on top;
    : date: 2020-12-30;
    zcat .hry/book_page.rdb.Z | sorttable -r | select_first book | ncolumn insert_time | rdb_dDate | rename d_date latest | column latest page book | sorttable -r | tiddlylink book | threeColumnTiddly
}
echo git_init 1>&2
