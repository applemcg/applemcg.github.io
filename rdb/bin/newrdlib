_lesscolumn () 
{ 
    : remove arguments from the existing header;
    : date: 2017-05-12;
    report_notfile ${1:-"no FILE argument"} && return 1;
    local hdr=$(sed 1q $1);
    local rtn="";
    : read -p "$(myname) ( file: $1, remove: $2 ); hdr =( $hdr )" < /dev/tty;
    for col in $hdr;
    do
        for non in ${*:2};
        do
            [[ $non == $col ]] && continue;
            rtn="$rtn $col";
            : read -p "$(myname) ( $* ); rtn =( $rtn )" < /dev/tty;
        done;
    done;
    echo $rtn
}
column_data () 
{ 
    : app_trace $*;
    rdb_datafrom column $*
}
column_unique () 
{ 
    : app_trace $*;
    cat $2 | rdb_datafrom column $1
}
cpdir () 
{ 
    report_notdirectory $1 && return 1;
    report_notdirectory $2 && return 2;
    pushd $1 > /dev/null;
    tar cf - . | ( cd $2;
    tar xf - );
    popd > /dev/null
}
filesize () 
{ 
    report_notargcount 1 $# file ... && return 1;
    case $# in 
        1)
            set -- $(wc -c $1);
            echo $1
        ;;
        *)
            rdb_hdr Offset Filename;
            wc -c $* | awk '$2 !~ /^total$/'
        ;;
    esac
}
headon () 
{ 
    return
}
helpme () 
{ 
    return
}
howmany () 
{ 
    return
}
interdash () 
{ 
    return
}
listtosh () 
{ 
    return
}
lowercase () 
{ 
    return
}
rd_addf () 
{ 
    report_notfile ${1:-NoSuchFile} && { 
        comment rd_initf $1;
        return 1
    };
    report_notargcount 2 $# && return 2;
    report_notfile $RD_PACKED && return 3;
    :;
    : do not do an RDPUT here. this allows the current table;
    : to re-order the fields in the history as well.;
    :;
    back up $RD_TABLE;
    local fields=$(args_uniq $RD_CFIELDS ${*:2});
    :;
    : ------------- establish the field order in both history and table --;
    : ---------------------------------------- and remove blank records --;
    :;
    zcat $RD_PACKED | tee $RD_TEMP | column {insert,delete}_time $fields > $RD_HISTORY;
    :;
    rd_compress;
    :;
    column $fields < $RD_TABLE | awk NF > $RD_TEMP;
    mv $RD_TEMP $RD_TABLE;
    :;
    rd_syncf $RD_TABLE;
    back up $RD_TABLE $RD_PACKED
}
rd_addf_test () 
{ 
    rm -f *foo*;
    cp ~/Dropbox/todo.rdb foo.rdb;
    cp ~/Dropbox/.bak/h.todo.rdb.Z h.foo.rdb.Z;
    rd_addf foo.rdb newfoo oldbar
}
rd_awk_builtin () 
{ 
    : app_trace $*;
    : todo: move out to rdbcmdlib;
    curl http://www.math.utah.edu/docs/info/gawk_13.html 2> /dev/null | grep -i '<DT><CODE>.*(<VAR>' | sed 's/.*<CODE>//; s/(.*//'
}
rd_before () 
{ 
    : app_trace $*;
    row "date < $(rd_date $1)"
}
rd_canon () 
{ 
    : date: 2017-03-26;
    : date: 2017-12-18;
    : from: rdb_canon;
    : app_trace $*;
    case $1 in 
        h.*.rdb.Z)
            set ${1#h.};
            set h.$1 ${1%.Z};
            zcat $1 | rdb_current | rdb_write $2
        ;;
        h.*.rdb)
            : backs up, removes compressed history;
            : compresses an existing history;
            : recursively deals with compressed history;
            back up $1.Z;
            rm -f $1.Z;
            doit compress $1;
            rd_canon $1.Z
        ;;
        *.rdb)
            rd_syncf $* || return 1;
            newest $RD_PACKED $RD_TABLE || rd_syncf $RD_TABLE
        ;;
        *)
            [[ -f $1.rdb ]] && { 
                $(myname) $1.rdb;
                return
            };
            comment rm -f $1
        ;;
    esac
}
rd_cat () 
{ 
    : date: 2017-05-12;
    cat $1;
    shift;
    for f in $*;
    do
        tail +3 $f;
    done
}
rd_columns () 
{ 
    : enumerate the columns in an RDB table;
    set -- {1..129};
    while [ -n "$2" ]; do
        eval nC$1=$2;
        shift;
    done
}
rd_compress () 
{ 
    report_notfile ${RD_HISTORY:-NO_RD_HISTORY_NAME} && return 1;
    : app_trace $*;
    [[ -f $RD_PACKED ]] && backup $RD_PACKED;
    rm -f $RD_PACKED;
    compress $RD_HISTORY
}
rd_current () 
{ 
    ${*:-echo} $RD_TABLE
}
rd_data () 
{ 
    : app_trace $*;
    cat ${1:--} | column_data ${*:2}
}
rd_demoinit () 
{ 
    : command line helper;
    set foo.rdb;
    rm -f *$1*;
    rd_syncf;
    rd_syncf $1;
    rd_syncf $1 this that other;
    rd_syncf $1;
    zcat h.$1.Z;
    ls -lrt *$1*;
    rm -f *$1*;
    declare -f rd_demoinit
}
rd_files () 
{ 
    eval echo $(for f in RD_{TABLE,ERRF,TEMP,HISTORY,PACKED}; do printf "\$$f "; done)
}
rd_fixhistory () 
{ 
    : date: 2017-12-17;
    report_notcommand ${1:-NeedCommandArgument} && return 1;
    zcat $RD_PACKED | $1 | tee $RD_HISTORY;
    comment OK?, then compress $RD_HISTORY
}
rd_fun () 
{ 
    : date: 2019-08-12;
    printf "%s\tverify\tfunction\t\n" $1
}
rd_head () 
{ 
    comment TRACE rd_head $# ARGS $*;
    quietly comment -- common relational data header;
    rd_hlistd;
    echo "$HEAD";
    echo "$DASH";
    arglist=$1;
    Cs="     1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20";
    Cs="$Cs 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40";
    Cs="$Cs 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60";
    set -- $Cs;
    while test -n "$2"; do
        eval nC$1=$2;
        shift;
    done;
    C=1;
    for I in $HEAD;
    do
        COLIN="$COLIN $I=\$$C;";
        COLOUT="$COLOUT \$$C=$I;";
        eval C=\$nC${C};
    done
}
rd_help () 
{ 
    rd_addf_doc;
    rd_syncf_doc
}
rd_historyfunctions () 
{ 
    ${*:-echo} flip_mddyy rd_nontoday;
    comment maybe used in call to rd_fixhistory
}
rd_implementd () 
{ 
    : date: 2019-08-12;
    comm -12 <(cat command.rdb | column command 2>.column.err | headoff| sort) <(functions rdlib |sort )
}
rd_implemented () 
{ 
    : date: 2019-08-12;
    comm -12 <(cat command.rdb | column command 2>.column.err | headoff| sort) <(functions rdlib |sort )
}
rd_init () 
{ 
    : date: 2018-01-15;
    fam_iam;
    return;
    :;
    : hdr: -- RD ------------------------------------- PUBLIC Functions --;
    :;
    smart_def rd_public rd_{init,help,{addf,syncf}{,_doc}};
    smart_add rd_public rd_{init{copy,f},schema,cat,files};
    smart_add rd_public rd_{compress,current,packed};
    smart_add rd_public rd_{before,since,data,sortuniq};
    smart_add rd_public rd_{nospace,popular,reorder,rowsof};
    smart_add rd_public rd_{fixhistory,nontoday};
    :;
    smart_def rd_fixhistoryfunctions rd_nontoday;
    :;
    smart_def rd_utils rdput;
    smart_add rd_utils for_{missing,remaining_args};
    :;
    smart_def public_hint public_{home,libraryname,hint};
    :;
    smart_function rd_locality;
    :;
    : ------------------- same PUBLIC_BIN, but separate library --;
    :;
    public_libraryname rdlib;
    init_discoverfile ~/bin/rdlib ~/lib/rdlib.txt rd_init;
    [[ -s ~bin/rdlib ]] || rm -f ~/bin/rdlib;
    :;
    echo public_hint ff, public_vars
}
rd_initcopy () 
{ 
    : app_trace $(nava RD_HISTORY; nava RD_CFIELDS);
    report_isfile $RD_HISTORY && { 
        rm -f $RD_HISTORY;
        return
    };
    : prepend history fields;
    rdb_hdr {insert,delete}_time $RD_CFIELDS > $RD_HISTORY
}
rd_initf () 
{ 
    case $1 in 
        h.*)
            report_isfile $1 as it is a History File. && return 2
        ;;
        *)
            report_notfile ${1:-"No File"} && { 
                comment rd_schema table field ...;
                return 1
            }
        ;;
    esac;
    setenv RD_NAME ${1%.*};
    setenv RD_TABLE $1;
    setenv RD_HISTORY h.$RD_TABLE;
    setenv RD_PACKED $RD_HISTORY.Z;
    setenv RD_TEMP $RD_NAME.tmp;
    setenv RD_ERRF $RD_NAME.err;
    setenv RD_CFIELDS $(sed 1q $RD_TABLE);
    :;
    local boiler=": mfg: $(myname 2);: date: 2019-01-23";
    eval "rd_datarow () { $boiler; report_notpipe && return 1; $(rd_rowsof $RD_CFIELDS); }";
    return 0
}
rd_lastofkey () 
{ 
    rd sort -r | column | printfirst | rd sort
}
rd_list () 
{ 
    : mfg: fam_iam;
    : date: 2019-01-23;
    sfg ^rd_ 2> /dev/null
}
rd_listfmt () 
{ 
    comment TRACE $# rd_listfmt ARGS $*;
    quietly comment Relational Data LIST ForMaT;
    [[ -z "$HEAD" ]] && { 
        echo $0 $* 1>&2;
        ( echo $DASH;
        cat ) | listtotable | $0 $*;
        return 0
    }
}
rd_locality () 
{ 
    : app_trace $*;
    smart_install rd;
    smart_def rd_private rd_{locality,private}
}
rd_nospace () 
{ 
    : app_trace $*;
    pick $(rd_data $* | sed 's/ /_/g')
}
rd_packed () 
{ 
    : Relational Data -- update packed history;
    : from: rdput;
    : date: 2017-12-24;
    : date: 2018-01-15;
    :;
    report_notfile $RD_TABLE && return 1;
    : app_trace $*;
    awk NF $RD_TABLE > $RD_TEMP;
    mv $RD_TEMP $RD_TABLE;
    :;
    for_existing $RD_PACKED uncompress;
    :;
    : -------------------------------------------------- no PACKED file --;
    :;
    back up $RD_HISTORY $RD_TABLE;
    :;
    : awk program, rdupdate.awk depends on knowing;
    : history, and before data file;
    :;
    local now=$(date '+%y%m%d%H%M%S');
    local awk=$(awk_file rdupdate);
    : app_trace NOW: $now, AWK: $awk;
    :;
    awk -F'\t' -v now=$now -f $awk $RD_HISTORY $RD_TABLE > $RD_TEMP;
    :;
    chmod +x $RD_HISTORY;
    cat $RD_TEMP > $RD_HISTORY;
    : --------------------------------------------- restore PACKED file --;
    rd_compress
}
rd_popular () 
{ 
    : app_trace $*;
    rd sort | rduniq | rd sort -rn | rd sed ${1:-12}q | ncolumn Count
}
rd_printfirst () 
{ 
    : date: 2019-08-12;
    compute "if (printed[$1]++) { next };"
}
rd_printlast () 
{ 
    : date: 2019-08-12;
    rd sort -rn | compute "if (printed[$1]++) { next };"
}
rd_reorder () 
{ 
    : edit, re-order the fields in an rdb table;
    : usage cat table | column $(rd_reorder table);
    :;
    report_notfile $1 && return 1;
    sed 1q $1 | tr '\t' '\n' > .x;
    pr -tn .x 1>&2;
    ed .x;
    set $(< .x);
    echo $*
}
rd_schema () 
{ 
    : defines the table schema;
    : writes and compresses history;
    : --------------------------------------- does NOT use inif --;
    :;
    report_isfile $1 && return 1;
    :;
    report_notargcount 2 $# file field ... && return 2;
    :;
    local table=$1;
    shift;
    local history=h.$table;
    local packed=$history.Z;
    :;
    rdb_hdr $* > $table;
    rdb_hdr insert_time delete_time $* > $history;
    :;
    compress $history;
    back up $table $packed
}
rd_settings () 
{ 
    : date: 2018-03-10;
    cmd_log;
    set | grep ^RD_
}
rd_since () 
{ 
    : app_trace $*;
    row "date >= $(rd_date $1)"
}
rd_sortuniq () 
{ 
    rd sort | uniq -c | awk '
       BEGIN   { OFS = "\t" }
       NR == 1 { $1 = "count" }
       NR == 2 { $1 = "-----" }
               { print }
    ' | sed '
         s/\(^ *[0123456789][0123456789]*\)  */\1	/
    '
}
rd_stat () 
{ 
    : date: 2017-12-23;
    cmd_log;
    rdb_hdr date wkday chars file;
    stat_day $* | sed 's/"//g' | awk '{ printf "%s\t%s\t%7d\t%s\n", $11, $12, $8, $NF }'
}
rd_syncf () 
{ 
    : 2019-02-14 back up_version is now backup_ver;
    pushd $(dirname $1) > /dev/null;
    set $(basename $1);
    rd_initf $1 || { 
        popd;
        return 1
    };
    :;
    app_trace PWD: $PWD, $*;
    : --------------------------- save first version of the day --;
    backup_init;
    :;
    [[ -d ${DIR_VERSION}/$(ver_date) ]] || back_ver;
    :;
    :;
    : -------------------------------------- rest state: TABLE and PACKED exist --;
    :;
    for_existing $RD_HISTORY rd_compress;
    : --------------------------------------- may be first time --;
    for_missing $RD_PACKED rd_initcopy;
    for_existing $RD_HISTORY rd_compress;
    report_notfile $RD_PACKED && { 
        [[ -f ${DIR_BACKUP}/$RD_PACKED ]] || { 
            popd;
            return 3
        };
        cp ${DIR_BACKUP}/$RD_PACKED .
    };
    : ------------------------------------------- update PACKED --;
    :;
    rd_packed;
    back_up $RD_PACKED $RD_TABLE;
    for_remaining_args $*;
    popd > /dev/null;
    return 0
}
rd_tallycolumn () 
{ 
    : date: 2019-08-12;
    report_notpipe && return 1;
    report_notargcount 1 $# field && return 2;
    column $1 | addcol tally | compute "tally = ++count[$1]" | column tally $1 | rd_printlast $1
}
rd_unimplemented () 
{ 
    : date: 2019-08-12;
    comm -23 <(cat command.rdb | column command 2>.column.err | headoff| sort) <(functions rdlib |sort )
}
rd_unrecorded () 
{ 
    : date: 2019-08-12;
    comm -13 <(cat command.rdb | column command 2>.column.err | headoff| sort) <(functions rdlib |sort )
}
rd_variable () 
{ 
    : mfg: fam_iam;
    : date: 2019-01-23;
    eval RD_$1=$2
}
rd_vars () 
{ 
    set | grep ^RD_
}
rdb_active () 
{ 
    : date: 2017-07-10;
    : date: 2017-07-18;
    report_notfile $1 && return 1;
    zcat $1 | row \!delete_time | ncolumn delete_time
}
rdb_allHistory () 
{ 
    : date: 2019-04-07;
    ignore pushd $(dirname $1);
    zcat h.$(basename $1).Z;
    ignore popd;
    ignore cleandirlist
}
rdb_at () 
{ 
    : app_trace $*;
    row "insert_time ~ /^$1/ || delete_time ~ /^$1/"
}
rdb_changehistory () 
{ 
    : date 2017-02-12;
    zcat $1 | column {insert,delete}_time | rd sort -r | rduniq
}
rdb_colrename () 
{ 
    : ~ fromFieldName toNewName;
    : by modifying the matching column name;
    : on the first line of an /RDB file;
    : date 2016-11-15;
    report_notpipe && return 1;
    awk -v fm=$1 -v to=$2 '
    BEGIN   { OFS = "\t" } 
    NR == 1 {
              for (i=1; i<=NF; i++) {
                  if ($i == fm) 
                      $i = to
                  }
            }
            { print }
    '
}
rdb_column () 
{ 
    : app_trace $*;
    local boiler=": mfg: $(myname 2);: date: 2019-01-23";
    eval "${1}_${2} () { $boiler; rdb_now $1 | column $2 | rd sort -u; }"
}
rdb_data () 
{ 
    set -- $1 ${2:-.};
    for f in $1 $1.rdb;
    do
        [[ -f $1 ]] && rd_syncf $1;
        [[ -f $2/h.$f.Z ]] && { 
            zcat $2/h.$f.Z;
            return
        };
    done
}
rdb_datafrom () 
{ 
    : app_trace $*;
    "$@" | tail +3
}
rdb_deletes () 
{ 
    set -- ${1%.rdb};
    set -- $1 h.$1.rdb.Z delete_time;
    [[ -f $2 ]] || { 
        comment USAGE rdb_deletes STEM of h.STEM.rdb.Z;
        ls h.*.rdb.Z 1>&2;
        return
    };
    shift;
    : app_trace $# $*;
    zcat $1 | column $2 | rd sort | rd uniq -c | sed 's/^ *//' | sp2tab | rdb_create count $2
}
rdb_editorusers () 
{ 
    : app_trace $*;
    awk '$3 ~ /rdb_editor/ { print $4 }' ~/Dropbox/log/editor.log
}
rdb_fieldcheck () 
{ 
    : date: 2019-08-04;
    awk -F'\t' '!p[NF]++ { print NF, $0 }' $*
}
rdb_fieldids () 
{ 
    : returns a COL string label=$N, ... assigning Nth field to column NAME;
    : ------------------------- save the header fields --;
    : date 2017-03-26;
    local HEAD="";
    while [ -n "$1" ]; do
        case $1 in 
            BEGIN | END | FS | NF | NR | FNR | FILENAME | ARGC | ARGV | RS | OFS | ORS | OFMT | SUBSEP)
                comment USING a Reserved Name: $1 as a Field
            ;;
            length | srand | int | substr | index | match | split | sub | gsub | sprintf | system | getline | function)
                comment USING a builtin function $1 as a Field
            ;;
            *)
                HEAD="$HEAD $1"
            ;;
        esac;
        shift;
    done;
    : ---------------------------- allow for 129 fields --;
    : history: seq, jot, bash {...};
    set -- {1..129};
    while [ -n "$2" ]; do
        eval nC$1=$2;
        shift;
    done;
    local C=1;
    : app_trace $HEAD;
    : ------------- align HEAD names with field numbers --;
    local COL="";
    for I in $HEAD;
    do
        case $COL in 
            *$I=*)
                comment "duplicate "$I" in column names: $COL"
            ;;
            *)
                COL="$COL $I=\$$C;";
                eval C=\$nC$C
            ;;
        esac;
    done;
    : app_trace COL: $COL;
    echo $COL
}
rdb_hdrOf () 
{ 
    : date 2017-01-21;
    report_notfile $1 && return 1;
    rdb_hdr $(sed 1q $1)
}
rdb_hdx2 () 
{ 
    : collapse {insert,delete}_time into {i,d}_date;
    : date: 2019-04-20;
    : date: 2019-06-07 a good place to add the spaceit survivor;
    : date: 2019-07-14;
    report_notargcount 1 $# family for FAM_{history,columns} && return 1;
    set ${1}_columns;
    report_notfunction $1 && return 1;
    report_notpipe && return 2;
    set -- $($1);
    trace_call $*;
    tee .$(myname).000 | addcol i_date d_date | tee .$(myname).001 | compute 'i_date = substr(insert_time,1,6); d_date = substr(delete_time,1,6)' | tee .$(myname).002
}
rdb_history () 
{ 
    : app_trace $*;
    for_existing h.$(rdb_name $1).Z zcat
}
rdb_historyname () 
{ 
    : smart_ops returns full path to history file;
    : date: 2019-04-11;
    ${2:-echo} $PWD/h.$1.Z
}
rdb_init () 
{ 
    : app_trace $*;
    : source cmdlib
}
rdb_inserts () 
{ 
    set -- ${1%.rdb};
    set -- $1 h.$1.rdb.Z insert_time;
    [[ -f $2 ]] || { 
        comment USAGE rdb_inserts STEM of h.STEM.rdb.Z;
        ls h.*.rdb.Z 1>&2;
        return
    };
    shift;
    : app_trace $# $*;
    rdb_hdr count $2;
    zcat $1 | column $2 | rd sort | rd uniq -c | sed 's/^ *//' | rdb_datrdb_data2tab
}
rdb_join () 
{ 
    : date: 2017-05-11;
    function arg_colnames () 
    { 
        while [[ $# -gt 0 ]]; do
            case $1 in 
                -o)

                ;;
                -*)
                    shift
                ;;
                *)
                    [[ -f $1 ]] || echo $1
                ;;
            esac;
            shift;
        done
    };
    function arg_filename () 
    { 
        for f in $*;
        do
            [[ -f $f ]] && echo $f;
        done
    };
    function arg_flags () 
    { 
        while [[ $# -gt 0 ]]; do
            case $1 in 
                -o)

                ;;
                -*)
                    echo $1 $2;
                    shift
                ;;
            esac;
            shift;
        done
    };
    : non-flag args are either files or column names;
    local cols=$(arg_colnames $*);
    local args=$(arg_flags $*);
    set $(arg_filename $*);
    report_notargcount 2 $# file file ... man join && return 1;
    local f1=$1;
    local f2=$2;
    local col1=$(sed 1q $f1);
    local col2=$(sed 1q $f2);
    set $col1;
    local cols=${cols:-$1};
    local new1=$(columnlist $cols $col1);
    local new2=$(columnlist $cols $col2);
    local toun="toun cols args f1 col1 f2 col2 new1 new2";
    foreach nava $toun 1>&2;
    rm -f .tmp.{a,b}*;
    set .tmp.{a,b}$$;
    cat $f1 | column $new1 | tail +3 | sort > $1;
    cat $f2 | column $new2 | tail +3 | sort > $2;
    rdb_hdr $(columnlist $new1 $new2);
    join $args -t '	' $1 $2 | tee .joined.rdb;
    comment rm -f $1 $2;
    unset $toun
}
rdb_key () 
{ 
    : app_trace $*;
    rdb_col $1 $(rdb_fields $1) | rd sort -u
}
rdb_match () 
{ 
    : app_trace $*;
    comm $* <(ls *.rdb) <(ls h.*.Z | sed 's/h.//; s/.Z//')
}
rdb_name () 
{ 
    set -- ${1%.rdb}.rdb;
    [[ -f $1 ]] || { 
        comment no RDB file $1;
        comment local RDB;
        ls *.rdb 1>&2;
        return 1
    };
    : app_trace $# $*;
    newest h.$1.Z $1 || rd_syncf $1;
    echo $1
}
rdb_nodups () 
{ 
    : removes duplicate records from an RDB file;
    : echos command to remove NXT file, or;
    : command to move NXT to RDB, leaves diffs on DIF;
    : date: 2017-05-16;
    report_notfile $1 && return 1;
    set $1 ${1%.rdb}.{nxt,dif};
    rd sort -u < $1 > $2;
    diff $1 $2 > $3 && { 
        echo rm $2 $3
    } || echo mv $2 $1
}
rdb_nohistory () 
{ 
    : ~;
    : which RDB files have no history;
    set .hz;
    ls h.*rdb.Z | sed 's/h\.//; s/.Z$//' > $1;
    ls *.rdb | command comm -13 $1 -;
    rm -f $*
}
rdb_onlytime () 
{ 
    : app_trace $*;
    column insert_time delete_time
}
rdb_qshape () 
{ 
    tawk '
    NR == 1      { fields = NF }
    NF != fields { printf "%4d %3d: %s\n", NR, NF, $0 }
    END          { printf "file %s fields %d\n", FILENAME, fields > "/dev/stderr" }
    ' $1
}
rdb_rcheck () 
{ 
    : date: 2019-08-04;
    tawk '!p[NF]++ { print NF, $0 }' $*
}
rdb_record () 
{ 
    : app_trace $*;
    tail +3
}
rdb_records () 
{ 
    : date: 2017-07-10;
    : date: 2017-07-16;
    : date: 2017-07-18;
    cmd_log;
    set $1 h.$1.Z;
    report_notfile $1 && return 1;
    rd_syncf $1;
    rdb_active $2 | ncolumn insert_time
}
rdb_repairnotes () 
{ 
    cat <<'EOF'
  $ rdb_repair file.rdb "selection critera"
the selection criteria produces two files:
   file.edt -- the selection
   file.not -- the rest of the data
manually edit the file.edt until satisfied, then
restor the file with these commands:
  $ rdb_cat file.edt file.not > file.nxt
  $ rdput file.rdb
  $ mv file.nxt file.rdb
  $ rdput file.rdb
  $ rm -f file.edt file.not
maybe this could be called rdb_repair_finish
EOF

}
rdb_smart () 
{ 
    smart_def $1 $(lib)/${2:-$1}.rdb
}
rdb_sum () 
{ 
    rdb_hdr $*;
    column $* | tail +3 | tawk '
        {
	  nc=NF;
	  for (i = 1; i<= NF; i++) sum[i] += $i
        }
    END {
	  sep="";
	  for (i=1; i<=nc; i++) {
	    printf "%s%f", sep, sum[i]
	    sep = "\t"
         }
    printf "\n"
    }'
}
rdb_timetally () 
{ 
    : date: 2017-05-12;
    zcat h.$1.Z | column {insert,delete}_time | rd sort | rduniq
}
rdb_today () 
{ 
    : app_trace $# $*;
    set -- $(yymmdd)000000 ${1:-tasks};
    rdb_data $2 | row "delete_time > $1 || insert_time > $1" | rdb_notinsert
}
rdb_whinsert () 
{ 
    : app_trace $*;
    rdb_history $1 | row '!delete_time' | ncolumn delete_time
}
rdb_write () 
{ 
    report_notfunction $1 && return 1;
    $1 | tee ${1}.rdb
}
rdbcmd_init () 
{ 
    : app_trace $*;
    declare -f rdupdate > /dev/null || { 
        . rdblib
    };
    declare -f rd_initf > /dev/null || { 
        . rdlib
    }
}
rdbcmd_qrf () 
{ 
    : app_trace $*;
    wh functions rdbcmdlib
}
rdbcmdlib_version () 
{ 
    printf "%s\t%s\n" rdbcmdlib 0.5.0
}
rdbfields () 
{ 
    : date: 2017-05-11;
    set $1 ${1%.rdb}.rdb;
    for f in $*;
    do
        [[ -f $f ]] && { 
            sed 1q $f;
            return
        };
    done;
    report_notfile $1 Nor rdbfile $2;
    return 1
}
rdbhome () 
{ 
    : date: 2019-08-04;
    ${*:-echo} $(home)/lib/rdb
}
rdbkup () 
{ 
    set -- ${1%.rdb};
    newest h.$1.rdb.Z $1.rdb || logjob $(doit rdput $1.rdb 2>&1)
}
rdeditor () 
{ 
    function _rdbfields () 
    { 
        sed 1q $1
    };
    function _rdtail () 
    { 
        rd tail -24 $1
    };
    set -- ${1%.rdb};
    set -- $1.rdb $1.fix $1.tbl ${2:-_rdtail};
    : app_trace $# $*;
    [[ -f $1 ]] || { 
        comment "USAGE ${FUNCNAME[0]} table[.rdb]";
        comment "Tables (on stdout for user):";
        ls *.rdb;
        return 1
    };
    [[ -f $2 ]] || { 
        comment "USAGE ${FUNCNAME[0]} Table [queryCmd]";
        comment "USING $4 to trim the $1 to $2, RETURN to continue";
        read a;
        $4 < $1 > $2
    };
    [[ "$(_rdbfields $1)" == "$(_rdbfields $2)" ]] || { 
        comment " .. NOW .. $2 needs IDENTICAL column names as $1";
        return 2
    };
    ( rdb_hdr $(_rdbfields $1);
    diff $2 $1 | grep '^> ' | sed 's/..//' ) > $3;
    ${EDITOR:-emacs} $2;
    ( cat $3;
    tail +3 $2 ) | rd sort > $1
}
rdget () 
{ 
    comment TRACE rdget $# ARGS $*;
    quietly comment -- the history of the rd file;
    case $1 in 
        */*)
            cd $(dirname $1);
            f=$(basename $1);
            shift;
            rdget $0 $f $*
        ;;
    esac;
    date=$(
   date '+%y%m%d%H%M%S'
   [ -f h.$1 -o -f h.$1.Z ] || rdinit $1
time=$(Lymdhms ${2:-$date})
CAT=cat
[ -f h.$1.Z ]; CAT=z${CAT}
selection=$(
  printf "insert_time <= %s && (%s < delete_time || delete_time ~ /^$/)"   $time $time)
$CAT h.$1 | row "$selection"
) > /usr/tmp/x.$1;
    ncolumn insert_time delete_time < /usr/tmp/x.$1 | sed 's/       *$//'
}
rdgetTest () 
{ 
    cp $HOME/lib/h.DocState .;
    rdget DocState 89053012;
    rdget DocState 8905301145;
    rdget DocState 8904;
    rdget DocState;
    sh -x ~/rdb/bin/rdget Journal 890704;
    cd $HOME/lib;
    cd $HOME/lib;
    sh2p ~/rdb/bin/rdget
}
rdget_test () 
{ 
    cp $HOME/lib/h.DocState .;
    rdget DocState 89053012;
    rdget DocState 8905301145;
    rdget DocState 8904;
    rdget DocState;
    sh -x ~/rdb/bin/rdget Journal 890704;
    cd $HOME/lib;
    cd $HOME/lib;
    sh2p ~/rdb/bin/rdget
}
rdgrep () 
{ 
    comment TRACE rdgrep $# ARGS $*;
    quietly comment -- /rdb grep;
    read HEAD;
    read DASH;
    cat <<EOF
$HEAD
$DASH
EOF

    case $0 in 
        *rdegrep)
            grep=egrep
        ;;
        *rdgrep)
            grep=grep
        ;;
        *rdfgrep)
            grep=fgrep
        ;;
    esac;
    $grep $*
}
rdinit () 
{ 
    comment TRACE rdinit $# ARGS $*;
    quietly comment -- create the h. file;
    quietly comment default is file.Z, from compress, uncompress;
    quietly comment System V default is file.z, from pack, unpack;
    z=${2:-Z};
    [ -f h.$1 -o -f h.$1.$z ] || { 
        fields insert_time delete_time $(sed 1q $1) > h.$1
    }
}
rdjointable () 
{ 
    comment TRACE jointable $# ARGS $*;
    quietly comment -- Join rdb tables;
    function setcol () 
    { 
        for col in $*;
        do
            case $column in 
                *$col*)

                ;;
                *)
                    echo $col
                ;;
            esac;
        done
    };
    trap 'rm -f .tmp.[abcd12]$$' 0 1 2 3 15;
    while [ -n "$1" ]; do
        arg=$1;
        case $arg in 
            -)
                break
            ;;
            -j)
                continue
            ;;
            -*)
                ARGS="$ARGS $arg"
            ;;
            *)
                if [ -f $arg ]; then
                    break;
                else
                    column="$column $arg";
                fi
            ;;
        esac;
        shift;
    done;
    [ -f "$2" ] || { 
        echo "Usage: $0 column table table";
        echo "$2 isnt a file";
        exit 3
    };
    exec < $1;
    read COL1;
    read DASH1;
    exec < $2;
    read COL2;
    read DASH2;
    NEW1=$(setcol $COL1);
    case "$NEW1" in 
        "")
            echo "No columns in first file: $1";
            exit 1
        ;;
        *)

        ;;
    esac;
    NEW2=$(setcol $COL2);
    case "$NEW2" in 
        "")
            echo "No columns in first file: $2";
            exit 2
        ;;
        *)

        ;;
    esac;
    : DASHES=$(
    : TODO: FIXME
    : echo "$column${NEW1:+
    : }$NEW1${NEW2:+
    : }$NEW2" | tr -c "\012" "[-*]"  |tr "\012" "    "
    : );
    HEADER=$(echo "$column${NEW1:+\t}$NEW1${NEW2:+\t}$NEW2"                 |tr '\012' '        ');
    column $column $NEW1 < $1 | tail +3 | sort | tee .tmp.a$$ | cut -f1 | sort -u > .tmp.1$$;
    column $column $NEW2 < $2 | tail +3 | sort | tee .tmp.b$$ | cut -f1 | sort -u > .tmp.2$$;
    ( fields "$COL2";
    comm -23 .tmp.1$$ .tmp.2$$;
    cat .tmp.b$$ ) | column $COL2 | tail +3 | sort > .tmp.d$$;
    ( fields "$COL1";
    comm -13 .tmp.1$$ .tmp.2$$;
    cat .tmp.a$$ ) | column $COL1 | tail +3 | sort > .tmp.c$$;
    fields $HEADER;
    awk -f ${RDB:-$HOME/rdb}/lib/join.awk .tmp.c$$ .tmp.d$$
}
rdlcanon () 
{ 
    comment TRACE rdlcanon $# ARGS $*;
    quietly comment -- Relational Data List CANONicalizer;
    sed '
       s/^  *//
       s/[         ][      ]*/     /
       s/^[^       ][^     ]*$/&   /
       s/ *        /       /g
    ' $*
}
rdlib_version () 
{ 
    printf "%s\t%s\n" rdlib 0.5.0
}
rdlint_doc () 
{ 
    cat <<'EOF'
   use this on LIST format data.  it guarantees
      a TAB before a SPACE.
 return code is complement of files "goodness"
   egrep returns 1 if NO matches were found
                 0 if ANY were.
 suggested usage:
    if { not rdlint foo >/dev/null ; }
    then
       ok to use foo
    else
        edit foo
    fi
 OR
    while { rdlint foo > foo.err ; }
    do
        edit foo.err foo
    done
EOF

}
rdsel () 
{ 
    : app_trace $*;
    row "$1 ~ /$2/"
}
rdseq () 
{ 
    comment TRACE rdseq $# ARGS $*;
    quietly comment -- Relational Data SEQence - a file;
    rd awk '{ printf "%04d\t%s\n", NR, $0 }' | sed ' 1s/^/seqno     /
           2s/^/-----      /
    '
}
rdtail () 
{ 
    : app_trace $*;
    rd tail -24 $1
}
rdtimes () 
{ 
    comment TRACE rdtimes $# ARGS $*;
    quietly comment -- deliver the event times in the history;
    column insert_time delete_time
}
rmblank () 
{ 
    return
}
rowhas () 
{ 
    : app_trace $*;
    row "$1 ~ /$2/"
}
rowis () 
{ 
    : app_trace $*;
    row "$1 ~ /^$2$/"
}
rowisnot () 
{ 
    : app_trace $*;
    row "$1 !~ /$2/"
}
soundex () 
{ 
    return
}
substitute () 
{ 
    return
}
tabletofact () 
{ 
    return
}
tabletom4 () 
{ 
    return
}
tabletorule () 
{ 
    return
}
tabletosed () 
{ 
    return
}
todo_columns () 
{ 
    : the data columns in the TODO database;
    : version: 1.0.0;
    ${*:-echo} thru proj todo
}
tomorrow () 
{ 
    : todo: do what needs doing, tomorrow;
    trace $*
}
trimblank () 
{ 
    return
}
uppercase () 
{ 
    return
}
wherefun_columns () 
{ 
    : version: 1.0.0;
    ${*:-echo} fname library others
}
